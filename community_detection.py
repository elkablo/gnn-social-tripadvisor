#!/usr/bin/env python3

import matplotlib.pyplot as plt
from mpl_toolkits.basemap import Basemap
import numpy as np
import networkx as nx
from networkx.algorithms.community import kernighan_lin_bisection, partition_quality, girvan_newman, louvain_communities, asyn_lpa_communities, label_propagation_communities
from networkx.algorithms.centrality import edge_betweenness_centrality
import argparse
from time import process_time

class CommunityDetection:
	def __call__(self, G):
		# measure elapsed time and compute partitioning quality
		beg = process_time()
		parts = self._call(G)
		end = process_time()
		print(f'{self.name} parts sizes: {list(map(len, parts))}')
		print(f'generated in {end-beg:.06f} cputime seconds')

		quality = partition_quality(G, parts)
		print(f'partitions quality: {quality}')

		return parts, quality

class KLDetection(CommunityDetection):
	name = 'Kernighan-Lin bisection'
	method = 'kernighan-lin'

	def _call(self, G):
		parts1 = kernighan_lin_bisection(G, weight='w', seed=42)
		parts2 = kernighan_lin_bisection(G.subgraph(parts1[0]), weight='w', seed=42)
		parts3 = kernighan_lin_bisection(G.subgraph(parts1[1]), weight='w', seed=42)
		parts = parts2 + parts3
		return parts

class LouvainDetection(CommunityDetection):
	name = 'Louvain'
	method = 'louvain'

	def _call(self, G):
		return louvain_communities(G, weight='w', seed=42)

class GirvanNewman(CommunityDetection):
	name = 'Girvan-Newman'
	method = 'girvan-newman'

	def _call(self, G, nparts=4):
		gn = girvan_newman(G, most_valuable_edge=lambda g: edge_betweenness_centrality(g, weight='w'))
		for i in range(nparts):
			communities = next(gn)

		return communities

community_detection_methods = { cls.method: cls for cls in [ KLDetection, LouvainDetection, GirvanNewman ] }

def draw_graph(com_det_method, G, parts, quality, output):
	print(f'drawing graph to file {output}')

	# create positions for graph via spring layout
	pos = nx.spring_layout(G, scale=0.1, seed=42, weight='w')

	# draw graph
	fig = plt.figure(figsize=(15, 10))
	nx.draw_networkx_edges(G, pos, width=0.5, edge_color=[(0, 0, 0, G[u][v]['w']/5) for u, v in G.edges])

	colors = [(1, 1, 0), (1, 0, 1), (0, 1, 1), (1, 0.5, 0), (0.5, 1, 0), (0.5, 0, 1), (0, 0, 1), (1, 0, 0.5), (0, 1, 0), (0, 1, 0.5), (1, 0, 0), (0, 0.5, 1)]
	for part in parts:
		nx.draw_networkx_nodes(G, pos, nodelist=part, node_size=3, node_color=colors.pop(), alpha=0.9)

	other_node_type = 'hotels' if G.graph["nodes"] == 'authors' else 'authors'

	fig.suptitle(f'{len(G.nodes)} {G.graph["nodes"]}, {len(G.edges)} edges\n' + \
		     f'{G.graph["nodes"]} with at least {G.graph["min_reviews"]} reviews,\n' + \
		     f'edges with at least {G.graph["min_common"]} common {other_node_type},\n' + \
		     f'{com_det_method} method, partition quality {quality[0]:.02f}, {quality[1]:.02f}', fontsize=16)

	# save figure
	fig.savefig(output, pad_inches=0, bbox_inches='tight')

def draw_map(G, parts, output):
	from random import shuffle

	print(f'drawing map to file {output}')

	fig = plt.figure(figsize=(30, 20))
	ax = plt.axes([0,0,1,1], frameon=False)
	ax.get_xaxis().set_visible(False)
	ax.get_yaxis().set_visible(False)

	# use the cylindrical projection for the map
	m = Basemap(projection='cyl', llcrnrlat=25, urcrnrlat=52, llcrnrlon=-125, urcrnrlon=-68, lat_ts=20, resolution='c')
	m.etopo(alpha=0.5)
	m.drawcountries()
	m.drawstates()

	# pop colors for partitions from this list
	colors = [(1, 1, 0), (1, 0, 1), (0, 1, 1), (1, 0.5, 0), (0.5, 1, 0), (0.5, 0, 1), (0, 0, 1), (1, 0, 0.5), (0, 1, 0), (0, 1, 0.5), (1, 0, 0), (0, 0.5, 1)]

	lons = []
	lats = []
	cols = []

	# each partition gets a differet color, get the locations for each hotel
	for part in parts:
		lons += [G.nodes[hid]['gps'][1] for hid in part]
		lats += [G.nodes[hid]['gps'][0] for hid in part]
		cols += [colors.pop()] * len(part)

	# remap locations to the Basemap projection
	lons, lats = m(lons, lats)

	# Shuffle the points so that they are drawn in random order.
	# This can detect anomalies if maps from several runs are created.
	zipped = list(zip(lons, lats, cols))
	shuffle(zipped)
	lons, lats, cols = zip(*zipped)

	# do the scatter plot
	plt.scatter(lons, lats, color=cols, s=800, alpha=0.5)

	# and save
	fig.savefig(output, pad_inches=0, bbox_inches='tight')

parser = argparse.ArgumentParser(description='Utility to detect communities in a TripAdvisor review graph projected to authors or hotels')
parser.add_argument('-i', '--input', type=str, required=True,
		    help='input graph file generated by projection.py')
parser.add_argument('-o', '--output', type=str,
		    help='file to save the graph, with community information')
parser.add_argument('-d', '--draw-graph', type=str, metavar="FILE",
		    help='draw the graph with detected communities into image file FILE')
parser.add_argument('-M', '--draw-hotel-map', type=str, metavar="FILE",
		    help='draw the map with detected communities into image file FILE')
parser.add_argument('-m', '--community-detection', default='louvain', choices=community_detection_methods.keys(),
		    help='method of community detection')

def main():
	args = parser.parse_args()

	G = nx.read_gpickle(args.input)

	other_node_type = 'hotels' if G.graph["nodes"] == 'authors' else 'authors'
	print(f'input graph of {len(G.nodes)} {G.graph["nodes"]} with {len(G.edges)} edges')
	print(f'- each node having at least {G.graph["min_reviews"]} reviews')
	print(f'- each node having at least {G.graph["min_neighbors"]} neighbors')
	print(f'- each edge representing at least {G.graph["min_common"]} common {other_node_type}')
	if 'max_year' in G.graph and G.graph['max_year'] is not None:
		print(f'- each review published at most in year {G.graph["max_year"]}')

	com_det = community_detection_methods[args.community_detection]()

	print(f'detecting communities with method {args.community_detection}')

	# detect communities with given method
	parts, quality = com_det(G)

	# draw graph if requested
	if args.draw_graph is not None:
		draw_graph(com_det.name, G, parts, quality, args.draw_graph)

	# draw map if requested
	if args.draw_hotel_map is not None:
		if G.graph["nodes"] != 'hotels':
			parser.error('map can only be drawn for hotels, given file contains author projection')
		draw_map(G, parts, args.draw_hotel_map)

	# save graph with communities
	if args.output is not None:
		print(f'saving graph with community inforation to {args.output}')

		G.graph['communities'] = com_det.method, len(parts)

		# assign community IDs to nodes
		part_id = 0
		for part in parts:
			for node in part:
				G.nodes[node]['community'] = part_id
			part_id += 1

		nx.write_gpickle(G, args.output)

if __name__ == '__main__':
	main()
